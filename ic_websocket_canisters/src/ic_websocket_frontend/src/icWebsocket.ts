import { ic_websocket_backend } from "../../declarations/ic_websocket_backend";

import {
  Cbor,
  HttpAgent
} from "@dfinity/agent";
import { Principal } from "@dfinity/principal";
import addNotification from "./utils/addNotification";

import * as ed from '@noble/ed25519';

import validateBody from "./utils/validateBody";

const CLIENT_SECRET_KEY_STORAGE_KEY = "ic_websocket_client_secret_key";

type WsMessage = {
  key: string;
  cert: ArrayBuffer;
  tree: ArrayBuffer;
  val: ArrayBuffer;
}

type WsMessageContent = {
  sequence_num: number;
  timestamp: number;
  message: ArrayBuffer;
};

export default class IcWebSocket {
  canisterId: Principal;
  nextReceivedNum: number;
  instance: WebSocket;
  secretKey: Uint8Array | string;
  agent: HttpAgent;
  sequenceNum = 0;

  constructor(canisterId: string, gatewayAddress: string, networkUrl: string, localTest: boolean, persistKey?: boolean) {
    this.canisterId = Principal.fromText(canisterId);
    this.nextReceivedNum = -1; // Received signed messages need to come in the correct order, with sequence numbers 0, 1, 2...
    this.instance = new WebSocket(gatewayAddress); // Gateway address. Here localhost to reproduce the demo.
    this.instance.binaryType = "arraybuffer";
    this.bindEvents();

    if (persistKey) {
      // attempt to load the secret key from local storage (stored in hex format)
      const storedKey = localStorage.getItem(CLIENT_SECRET_KEY_STORAGE_KEY);

      if (storedKey) {
        console.log("Using stored key");
        this.secretKey = storedKey;
      } else {
        console.log("Generating new key");
        this.secretKey = ed.utils.randomPrivateKey(); // Generate new key for this websocket connection.
        localStorage.setItem(CLIENT_SECRET_KEY_STORAGE_KEY, ed.etc.bytesToHex(this.secretKey));
      }
    } else {
      console.log("Generating new key");
      this.secretKey = ed.utils.randomPrivateKey(); // Generate new key for this websocket connection.
    }

    this.agent = new HttpAgent({ host: networkUrl });
    if (localTest) {
      this.agent.fetchRootKey();
    }
  }

  async makeMessage(text: string) {
    // Our demo application uses simple text message.
    const content = Cbor.encode({
      text: text,
    });

    // Message with all required fields.
    const websocketMessage = Cbor.encode({
      client_key: await ed.getPublicKeyAsync(this.secretKey), // public key generated by the client
      sequence_num: this.sequenceNum, // Next sequence number to ensure correct order.
      timestamp: Date.now() * 1000000,
      message: content, // Binary application message.
    });

    // Sign the message
    const toSign = new Uint8Array(websocketMessage);
    const sig = await ed.signAsync(toSign, this.secretKey);

    // Final signed websocket message
    const message = {
      val: websocketMessage,
      sig: sig,
    };

    // Send CBOR encoded
    const wsMessage = Cbor.encode(message);
    return wsMessage;
  }

  sendMessage(message: ArrayBuffer) {
    console.log("Sending to canister.");
    this.instance.send(message);
    this.sequenceNum += 1;
  }

  bindEvents() {
    this.instance.onopen = this.onOpen.bind(this);
    this.instance.onmessage = this.onMessage.bind(this);
    this.instance.onclose = this.onClose.bind(this);
    this.instance.onerror = this.onError.bind(this);
  }

  async onOpen() {
    console.log("[open] Connection opened");
    const publicKey = await ed.getPublicKeyAsync(this.secretKey)
    // Put the public key in the canister
    await ic_websocket_backend.ws_register(publicKey);
    this.sequenceNum = 0;

    // Send the first message with client and canister id
    const cborContent = Cbor.encode({
      client_key: publicKey,
      canister_id: this.canisterId,
    });

    console.log("Sending first message", {
      client_key: publicKey,
      canister_id: this.canisterId,
    }, cborContent);

    // Sign so that the gateway can verify canister and client ids match
    const toSign = new Uint8Array(cborContent);
    const sig = await ed.signAsync(toSign, this.secretKey);

    const message = {
      content: cborContent,
      sig: sig,
    };

    // Send the first message
    const wsMessage = Cbor.encode(message);
    this.sendMessage(wsMessage);
    this.sequenceNum = 0;
  }

  async onMessage(event: MessageEvent<ArrayBuffer>) {
    if (this.nextReceivedNum == -1) {
      console.log(event.data);
      this.nextReceivedNum += 1;
    }
    else {
      const res = Cbor.decode<WsMessage>(event.data);

      let key, val, cert, tree;
      key = res.key;
      val = new Uint8Array(res.val);
      cert = res.cert;
      tree = res.tree;
      const websocketMsg = Cbor.decode<WsMessageContent>(val);

      // Check the sequence number
      const receivedNum = websocketMsg.sequence_num;
      if (receivedNum != this.nextReceivedNum) {
        console.log(`Received message sequence number (${receivedNum}) does not match next expected value (${this.nextReceivedNum}). Message ignored.`);
        return;
      }
      this.nextReceivedNum += 1;

      // Inspect the timestamp
      const time = websocketMsg.timestamp;
      const delaySeconds = (Date.now() * (10 ** 6) - time) / (10 ** 9);
      console.log(`(time now) - (message timestamp) = ${delaySeconds}s`);

      // Verify the certificate (canister signature)
      const valid = await validateBody(this.canisterId, key, val, cert, tree, this.agent);
      console.log(`Certificate validation: ${valid}`);
      if (!valid) {
        console.log(`Message ignored.`);
        return;
      }

      // Message has been verified
      const appMsg = Cbor.decode<{ text: string }>(websocketMsg.message);
      const text = appMsg.text;
      console.log(`[message] Message from canister: ${text}`);
      addNotification(text);
      this.sendMessage(await this.makeMessage(text + "-pong"));
    }
  }

  onClose(event: CloseEvent) {
    if (event.wasClean) {
      console.log(
        `[close] Connection closed, code=${event.code} reason=${event.reason}`
      );
    } else {
      console.log("[close] Connection died");
    }
  }

  onError(error: Event) {
    console.log(`[error]`, error);
  }
}